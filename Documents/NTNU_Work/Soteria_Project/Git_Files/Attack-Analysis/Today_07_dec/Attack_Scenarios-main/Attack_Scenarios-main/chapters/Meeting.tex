% !TeX root = ../sameplaper.tex
% !TeX spellcheck = en_US

\chapter{Project Meetings} %Project Soteria Attack Scenario}
\setcounter{section}{0}


\section{Weekly Meeting}
% subsection{Meeting With Ana and Flavio}

\begin{itemize}
    \item When a user forms a query the query can be sends for query computation in two ways
          \begin{enumerate}
              \item Users query is sent using user's metadata for query computation  to the server with users metadata. In this case authenticity of the user is verified from the user database stored in the server and same for the the service validity check. After successful authentication and verification the query computation is performed which is later decrypted and decoded and the obtained final plain result is forwarded to the user who submitted the query. This method have a drawback of maintaining users database on the server side and similarly for the service information of the users service information have to be stored. As more users registers in the institutions it have to constantly update and maintain the database. Similarly when a users registration have been withdrawn then it have to be updated into the server side which creates heavy overload on the server side.
              \item Users query is sent with institutions metadata. Here when a user asks for a query request users authenticity is verified in the client side portal itself. On successful authentication users are provided query encryption facility. On successful query encryption users query is sent with the institutions metadata storing the users metadata on the client side portal. Server side performs institution authentication and service validation of institution. On successful authentication and verification query computation is performed. The result is forwarded to the institution. Institution identifies the user who generated the query request from its database and sends it query result to the corresponding user.
          \end{enumerate}
    \item HE query result can be stored in one of the two places:
          \begin{enumerate}
              \item Server side: Query result is stored in the server side for pre-decided time interval. Before the time expires the query requester have to access the result else result is deleted from the database.
              \item Client side: Query result is stored in some database. The result remains in the database until the user access it. There is no time associated with the query result lifetime. Thus the user don't have to bother about the expiry of the query result.
          \end{enumerate}
    \item For data safeguard data diode can be used. A data diode is the one in which data only moves in one direction. Data diodes are hardware-based devices with two nodes or circuits—one send only and one receive only—that allow the flow of data in one direction only, from a source to a destination. It is also called as a unidirectional network. Firewalls can be used instead of data diodes.
    \item Force deviation and the system behaviour
    \item Memory overflow attack
    \item Targeted attack
    \item Network admin and Database admin should be completely separate and should never combine the two. Combination of these unknowingly may make the system vulnerable using the combination of attack techniques and leakages.
    \item System logs should be stored safely so that if something wrong happens then it can be analyzed later. However prevention is better than cure.
    \item What are the different type of denial of service attack?
    \item Attack on front end of the query?
    \item Attack on the underline messaging system?
    \item Can we quantify the risk associated with the HE deployment?
    \item For query encryption:
          \begin{enumerate}
              \item Initially QU have cleartext. From this prepare query predicate for a query.
              \item Perform encoding.
              \item Perform query encryption.
              \item Combination phase: In this phase lots of queries are combined with encryption predicates.
          \end{enumerate}
    \item When data flows from the high security domain to low security domain then in this case it creates a security problem. Thus this must be taken care of.
    \item When data flows from low security domain to high security domain data gets classified thus disposing of data becomes a real problem. Thus to handle disposing of data from low security domain to high security domain must be taken care of using proper procedures.  To handle such scenarios help of some third party or proxy organization is taken who checks security of on behalf of host party. This task is usually outsourced to avoid security breach.
    \item When a query comes to the server for query computation---validation or query well formness is checked before sending it for query computation. In this step following checks are performed:
          \begin{enumerate}
              \item Query is right or not
              \item Valid for user or not.
              \item Metadata came with the query is correct or not.
              \item Service parameters are correct or not.
          \end{enumerate}
    \item Client laptop by design is dishonest.
    \item Edge device is vulnerable and dishonest (Honest but curious are not trustworthy)
    \item Attack can have multiple actors taking part of attack to control viz. MITM attack.
    \item Attack can be on the protocol itself viz. TLS1.3
    \item Write separate user authentication from that of HE. Use whatever technology available today for FHE threat flow.
    \item Use different technologies to get verifiable computation.
    \item User has only decrypted and decoded result.
    \item Different institutions may have different (pk,sk) pair, Keys are kept by the isntitutions and are never exposed to anyone.
    \item User authentication should be backed up by the technologies available today viz. HTTPS, PKI etc.
    \item Mostly attacks are from client side including the passive attacks.
    \item Key management
    \item There is no algorithmic way of risk evaluation. Matrix for risk analysis some sort of inference if we can provide.
    \item Combine different technology and try to measure the risk.
    \item Explore the vulnerability of the client side.
    \item How to perform FHE key management
    \item User is never trusted in the deployment setting
\end{itemize}
\paragraph {$9^{th}$ march}
\begin{itemize}
    \item Our FHE computation assumes that the database is encoded and not encrypted.
    \item Next assumption: The server side owns the database.
    \item Thus, the database can be encrypted using AES and decrypted and computed in TEE.
    \item Our query comes in an encrypted form encrypted with a BGV encryption scheme.
    \item Focus on Bottom-up analysis rather than Top-down analysis viz. focus on CCA security, CPA security with an assumption that adversary is an Honest But Curious (HBC).
    \item Focus on how FHE computation is done, the vulnerability in FHE computation
    \item Write a list of FHE assumptions and security parameterization
    \item If assumptions do not hold true, then the list of potential threats that a bed actors can do
    \item If assumptions do not hold true, then what happens in CPA and CCA scenario
    \item Use of decryption oracle to decrypt result, can adversary also gets the decrypted result before decoding. In such scenarios, what should we do?
    \item Use a little bit of error and check the behavior of the client or the user. In doing so, what information can be learned?
    \item Explore ciphertext injection attack.
    \item Preserve the depth of the computation.
    \item Explore the equilibrium of the cost of preserving and the cost of attacking.
    \item Design system in such a way that even if an attacker breaks the system, the benefit of breaking the system should be same as that of the resources invested. In sort in gain for the attacker.
    \item Make a table and show what may cause what attack and its vulnerabilities.

    \item Consider FHE computation separately, separate from key generation and ciphertext generation
    \item Vulnerability assumptions for the HBC FHE computation setting
    \item What HBC server can do to the intermediate data
          \begin{itemize}
              \item Corrupt the computation
              \item Corrupt the values
              \item Deviation from the computed values by known quantity to know the user behavior and use this information to get side channel information
          \end{itemize}

\end{itemize}
\paragraph{6th April}
\begin{itemize}
    \item Vulnerabilities of deployment of HE
    \item Vulnerabilities of the encryption schemes
    \item Mention the attacks present in Martin's paper
    \item Potential attacks for deployment (decryption attacks like those proposed by Li and Miccancio)
    \item Analyze deployment
    \item Analyze by the encryption schemes
    \item Lattice attack on encryption schemes
    \item Mitigation for the deployment (Create the content in such a way that deployment can avoid the vulnerabilities present in the encryption scheme)
    \item Separate chapter-wise each of the topics
    \item After writing the chapters, connect the chapters.
    \item Security of FHE
    \item Attacks
          \begin{itemize}
              \item Key recovery attacks
              \item Attacks to break the key
              \item Attacks to break the homomorphic computation
              \item Side channel attacks
              \item Noise level left in the ciphertext
              \item When a user stops decryption of the ciphertext due to too much noise
              \item Man-in-the-middle type of attacks
              \item Other types of attacks like
                    \begin{itemize}
                        \item When the public keys are available to the user?
                        \item Encoding, parameter choices, Noise sampling, Encoding, Public key, etc are known to the attacker
                    \end{itemize}
          \end{itemize}
    \item Mitigation of attacks and corruption of ciphertext.
    \item Corruption of the final ciphertext should not be possible
    \item Error distribution and Noise distribution
\end{itemize}
\paragraph{19th June}
\begin{itemize}
    \item Study about dimension leakages
    \item Dimension leakages in case of HE
    \item size of database and entries leakages in case of HE
    \item plaintext parameter leakages in case of HE
    \item For loops in cotrol variable in case of HE
    \item In case of deployment leakages of data information and algorithms
    \item What is confidential in case case of data viz., dimension,for etc.
    \item Is there any infomration leakages will be there in case of padding with zero to the data used for encryprion
    \item Algorithmic leakages and recommandations
    \item What kind of information leakages will be there in case of leakages in the BGV and CKKS encryption schemes
    \item Or puttng otherwise, how  frequently the the keys should be refresh and Ciphertext as well
    \item Write schemes based on LWE NTRU and AGCD
\end{itemize}

\paragraph{26th June}
\begin{itemize}
    \item Summarized Our research objective to Alex
    \item Decided to target the SOK paper on Homomorphic Encryption to S\&P 2023 Dec 6 deadline and if we can not make it then try for PETS 2024
\end{itemize}




\section{Attacks on entities associated to HE deployment}

\subsection{Client-Side Components}
\begin{enumerate}
    \item User
          \begin{itemize}
              \item Opens the Query Service Client and requests the query service
              \item Sends its query to the query service client
          \end{itemize}
    \item Query service client
          \begin{itemize}
              \item Authenticates the requested service
              \item Extracts query predicates and builds the query
              \item Encrypts the query predicate and sends it to the Service Query portal
          \end{itemize}
    \item Encrypted Result store
          \begin{itemize}
              \item Encrypted result is decrypted in the Trusted Execution Environment
              \item Result is received by the query service client which sends result to the corresponding query user
          \end{itemize}
\end{enumerate}

\subsection{Server-Side Components}
\begin{enumerate}
    \item Service Query Portal
          \begin{itemize}
              \item Authenticates user and institution using
                    \begin{itemize}
                        \item User at Institution
                        \item Query Id
                        \item Query Data
                        \item Job Id
                    \end{itemize}
              \item Transmits user query to query engine
          \end{itemize}
    \item Service registry
          \begin{itemize}
              \item Validates institutions and possibly users
              \item Validates that the Institution/user is authorized to ask the requested service.
              \item On successful authorization forwards the users metadata
          \end{itemize}
    \item Service KMS
          \begin{itemize}
              \item Stores Institution id with Public and Evaluation keys (May be encrypted with HSM using symmetric key encryption like AES)
              \item Provides (institution specific) Evaluation Keys
              \item Encoding techniques is not known to the KMS
          \end{itemize}
    \item Data Store
          \begin{itemize}
              \item Stores database in cleartext or plaintext
              \item Query predicates are searched in the database for results
          \end{itemize}
    \item FHE Query Engine
          \begin{itemize}
              \item Does homomorphic computation using:
                    \begin{itemize}
                        \item User metadata
                        \item Institution eval keys
                        \item Data store
                    \end{itemize}
          \end{itemize}
    \item Encrypted Results Store
          \begin{itemize}
              \item Receives encrypted results from query engine
              \item Allows retrieval of results by relevant institution
          \end{itemize}
\end{enumerate}

\subsection{Passive Risks: leakage when components follows the protocol?}

\textcolor{blue}{Blue highlights indicate risks when component can observe client behaviour. (CCA)}

\textcolor{red} {Red highlights indicate risks associated with corrupted ciphertexts, and the possibility of ciphertext verification attacks. (CVA)}
\begin{enumerate}
    \item Service query portal
          \begin{itemize}
              \item Learns frequency of queries by institution
              \item Knows which institutions are valid
              \item Knows which users are valid at a given institution
              \item Processes a query
                    \begin{itemize}
                        \item Knows the query predicates
                        \item Sees ciphertext of query predicate
                    \end{itemize}
          \end{itemize}
    \item Service registry
          \begin{itemize}
              \item Learns frequency of queries by institution and by user
              \item Learns user/institution meta data
                    \begin{itemize}
                        \item Learns institution security level
                        \item Learns dimension of user input?
                        \item Type of service user/institution is registered for?
                    \end{itemize}
          \end{itemize}
    \item Service KMS
          \begin{itemize}
              \item Learns frequency of queries by institution
              \item Sees Eval keys: has access to a large quantity of ciphertexts
              \item Keys can be encrypted using the HSM can only see the encrypted Eval keys
          \end{itemize}
    \item Data Store
          \begin{itemize}
              \item \textcolor{blue}{If can observe client behaviour, may be able to infer (something about) user’s data: however unclear whether this component knows which request corresponds to which user.}
              \item If plaintext (not cleartext) learns something about parameters of schemes used
          \end{itemize}
    \item FHE Query Engine (closest to monolithic HE server from current modelling)
          \begin{itemize}
              \item Learns frequency of queries by institution
              \item Receives a query: same risks as service query portal
                    \begin{itemize}
                        \item Learns the query predicates
                        \item Sees ciphertext of query predicates
                    \end{itemize}
              \item Learns user/institution meta data: same risks as service registry
                    \begin{itemize}
                        \item Learns service security level
                        \item Size of evaluation key / query predicates size
                        \item Learns dimension of user input.
                        \item Type of service user/institution is registered for?
                    \end{itemize}
              \item Receives data: same risks as data store
              \item Receives eval keys: same risks as service KMS
              \item Sees result ciphertext
              \item additional risks come from information seen in conjunction
                    \begin{itemize}
                        \item Has query ciphertext AND eval keys
                        \item \textcolor{blue}{Sees database AND knows specific user}
                    \end{itemize}
          \end{itemize}
    \item Encrypted results store
          \begin{itemize}
              \item Understands frequency of queries by institution and by user from retrieval
              \item Sees result ciphertext
                    \begin{itemize}
                        \item Can infer something about query evaluation circuit
                        \item \textcolor{blue}{Can infer about ciphertext decryption from user/institution behaviour}
                    \end{itemize}
          \end{itemize}
\end{enumerate}


\subsection{Active Risks: leakage when components deviate from the protocol description?}
\textcolor{blue}{Blue highlights indicate risks when component can observe client behaviour. (CCA)}

\textcolor{red} {Red highlights indicate risks associated with corrupted ciphertexts, and the possibility of ciphertext verification attacks. (CVA)}
\begin{itemize}
    \item Service Query Portal
          \begin{itemize}
              \item Denial of service attacks
              \item Can substitute or modify query data ciphertext, possibly \textcolor{blue}{leading to decryption oracle creation} and/or \textcolor{red}{corrupted ciphertexts}
              \item Can change query logic
              \item Can swap institution ID, leading to \textcolor{red}{corrupted ciphertexts}
          \end{itemize}
    \item Service registry
          \begin{itemize}
              \item Can change metadata, which can lead to \textcolor{red}{corrupted ciphertexts}
          \end{itemize}
    \item Service KMS
          \begin{itemize}
              \item Denial of service
              \item Corruption of eval keys, leading to \textcolor{red}{corrupted ciphertexts }
              \item Corruption of public encryption key, leading to \textcolor{red}{corrupted ciphertexts}
              \item \textcolor{blue}{Can generate valid ciphertexts using public keys}
          \end{itemize}
    \item Data Store
          \begin{itemize}
              \item Denial of service
              \item Can modify database to try and infer something about query data \textcolor{blue}{by observing client behaviour}
              \item Can modify database to ensure decryption failures, leading to \textcolor{red}{corrupted ciphertexts}
          \end{itemize}
    \item FHE Query Engine
          \begin{itemize}
              \item All risks previously covered, and
              \item Can reply chosen query request by valid ciphertext
              \item Can generate any request and encrypt it
              \item Can corrupt the ciphertext for the correct query
              \item Can evaluate a different circuit other than the one requested
              \item Can generate \textcolor{blue}{valid ciphertexts associated to the query ciphertext}
              \item Can produce corrupt result
          \end{itemize}
    \item Encrypted Results Store
          \begin{itemize}
              \item Can use ciphertext received metadata/context to generate a \textcolor{red}{corrupted ciphertext}
              \item Can generate valid ciphertexts with known relationship to target by e.g. adding plaintexts and \textcolor{blue}{observe client behaviour to create a decryption oracle}
          \end{itemize}
\end{itemize}

